<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coursework | Phil Cooper-King]]></title>
  <link href="http://PhilCK.github.com/blog/categories/coursework/atom.xml" rel="self"/>
  <link href="http://PhilCK.github.com/"/>
  <updated>2012-10-24T19:52:20+01:00</updated>
  <id>http://PhilCK.github.com/</id>
  <author>
    <name><![CDATA[Phil CK]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Virtual Texture]]></title>
    <link href="http://PhilCK.github.com/blog/2012/10/24/virtual-texture/"/>
    <updated>2012-10-24T16:00:00+01:00</updated>
    <id>http://PhilCK.github.com/blog/2012/10/24/virtual-texture</id>
    <content type="html"><![CDATA[<p>So for my Honors project I've decided on <a href="http://en.wikipedia.org/wiki/MegaTexture#Virtual_texturing" title="Virtual Texture">virtual textures</a>, its a rather scary term (at least to me) but it actually has a lot in common with <a href="http://en.wikipedia.org/wiki/Virtual_memory" title="Virtual Memory">virtual memory</a>, and in most cases you can simply swap the word 'memory' with 'texture' to get an idea how it works.</p>

<p><blockquote><p>VTM systems are more flexible and mimic the virtual memory management of the OS:</p><footer><strong>Matthäus G Chajdas et al</strong> <cite>GPU Pro - Virtual Texturing 101</cite></footer></blockquote></p>

<p>That make me feel a little easier about topic. So what we have is an actual texture on a disc which contains all the data that we need but to much to squeeze into the GPU. A texture on the GPU which contains all the data that we currently need. And a <a href="http://en.wikipedia.org/wiki/Page_table" title="Page Table">page table</a> thats lets us find out where the bit of texture is that we are looking for, as it might not be in the same place when we come back to (Hence the virtual bit).</p>

<p>Rage has some nice visualisations you can turn on. On the left its showing the page numbers, and on the right its show the mip levels its rendering at. Green being the lowest, red highest.</p>

<p><img src="/post_images/Honors/rage_vis.jpg"></p>

<p>Well thats all very nice and all, but what does it actually give us? It would allow artists to create completely unique (ie. no repeating textures) texture detail over a very large area, it should also reduce our memory footprint as we are only loading up the data we need when we need it.</p>

<p>With all things though this doesn't come free. The first problem is its slow to hit the disc for data. When you are trying to load up data you could get a lot of texture popping. That isn't really desirable however it is almost inevitable with this kind of solution, there are some tricks to reduce it but it comes down to the usual game of trying to balance things out. Another problem (on the development side not runtime) is hardware <a href="http://en.wikipedia.org/wiki/Bilinear_filtering" title="Bilinear filtering">filtering</a>. When the hardware is doing a bilinear filtering it will be using data from its neighboring texels, which in this case could be an entirely different texture.</p>

<p>There is really good video on Virtual textures it over at <a href="http://silverspaceship.com/src/svt/" title="Silver Spaceship">silverspaceship.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Honors Project]]></title>
    <link href="http://PhilCK.github.com/blog/2012/10/08/honors-project/"/>
    <updated>2012-10-08T18:45:00+01:00</updated>
    <id>http://PhilCK.github.com/blog/2012/10/08/honors-project</id>
    <content type="html"><![CDATA[<p>The topic for my honors project was a hard decision. The two main contenders were <a href="http://en.wikipedia.org/wiki/Deferred_shading#Deferred_lighting" title="Deferred Lighting">deferred lighting</a> and <a href="http://en.wikipedia.org/wiki/MegaTexture#Virtual_texturing" title="Virtual Texturing">virtual texturing</a>, with a visual programming language and VR headsets taking the runners up topics. In the end I chose virtual texturing. Something that Rage used to generate some very petty scenes, and some very interesting texture popping.</p>

<p><img src="/post_images/Honors/rage.jpg" title="'Rage'" ></p>

<p>The basic idea is that you create a massive texture file, in Rages case I believe they could be up to 128,000 x 128,000 pixels then just stream off the hard-drive (or disc) the information you need based on your position in the world.</p>

<p><blockquote><p>Regardless of how much detail its texture might contain, you cannot display more texels than the screen has pixels.</p><footer><strong>Ben Garney</strong> <cite>Game Programming Gems 7 - Clipmapping</cite></footer></blockquote></p>

<p>The motivation is an old one, textures in the distance need not have as much detail in them as textures closer to the camera. But the two texture files might take up the same space on the GPU. So if we can stream in the amount of information when we need it we can save our-selfs a lot of memory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thrid Year Group Project]]></title>
    <link href="http://PhilCK.github.com/blog/2012/09/09/group-project/"/>
    <updated>2012-09-09T21:55:00+01:00</updated>
    <id>http://PhilCK.github.com/blog/2012/09/09/group-project</id>
    <content type="html"><![CDATA[<p>As part of our 3rd year in Uni, we had todo a group project. This was mainly an exercise in working with other disciplines and clients. A small group of us wanted to create our own game rather than pick from a selection of pre-produced briefs, so we pitched the game idea to the school, and managed to pickup some artists and audio people which we needed otherwise programmer art would have been a feature of our game.</p>

<p>A wee clip of one of the levels.</p>

<iframe src="http://player.vimeo.com/video/50893418" width="500" height="375" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>The main idea is you have no direct control over the player, but instead can morph into different objects that in-turn move you in the environment. During our final pitches Disney saw our game and showed some interest, nothings come of it yet, but it was nice to have somebody outside of the Uni show some interest in the game.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Faultline Terrain]]></title>
    <link href="http://PhilCK.github.com/blog/2012/02/01/faultline-terrain/"/>
    <updated>2012-02-01T19:58:00+00:00</updated>
    <id>http://PhilCK.github.com/blog/2012/02/01/faultline-terrain</id>
    <content type="html"><![CDATA[<p>This was an experiment of making procedural terrains using the faultline method.</p>

<iframe src="http://player.vimeo.com/video/35978061" width="500" height="281" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>This first attempt was a little mental, the falloff for the fault size was quadratic and started very large. The result was these scary mountainous landscapes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua Proof Of Concept]]></title>
    <link href="http://PhilCK.github.com/blog/2011/10/01/lua-proof-of-concept/"/>
    <updated>2011-10-01T19:58:00+01:00</updated>
    <id>http://PhilCK.github.com/blog/2011/10/01/lua-proof-of-concept</id>
    <content type="html"><![CDATA[<p>As part of our group-project in uni, we looked into the possibility of using <a href="http://www.lua.org/" title="Lua">Lua</a> embedded with our framework, which was built upon <a href="http://www.libgosu.org/" title="Gosu">Gosu</a>.
There was a desire to use Lua to speed up iteration speeds, and also to include non-programmer types in the development of the game.
The actual embededing of Lua and <a href="http://www.rasterbar.com/products/luabind.html" title="LuaBind">Luabind</a> was relatively easy, the hard part came in the finicky little bits of LuaBind, and the difficulty of of debugging Lua scripts.</p>

<iframe src="http://player.vimeo.com/video/31367803" width="500" height="375" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>We ended up ditching Lua for two reasons, its drain on my time, and the lack of interest (although initially shown) from the non-programmer's in the group to use it.</p>

<p>I’d like to revisit this some day though.</p>
]]></content>
  </entry>
  
</feed>
